#pragma once

#include <queue>
#include <map>
#include <boost/uuid/uuid.hpp>

#include <grpcpp/grpcpp.h>
#include <grpcpp/server.h>
#include <grpcpp/server_builder.h>
#include <grpcpp/server_context.h>

#include "signup/Server.h"
#include "signup/config.h"
// #include "nextapp.pb.h"
// #include "nextapp.grpc.pb.h"
// #include "nextapp/logging.h"
// #include "nextapp/errors.h"
// #include "nextapp/UserContext.h"
// #include "nextapp/certs.h"

#include "signup.pb.h"
#include "signup.grpc.pb.h"

#include "nextapp/util.h"


namespace nextapp::grpc {


class GrpcServer {
public:

    template <ProtoMessage T>
    std::string toJsonForLog(const T& obj) {
        return toJson(obj, server().config().options.log_protobuf_messages);
    }

    template <typename T>
    class ReqBase {
    public:
        ReqBase() {
            LOG_TRACE << "Creating instance for request# " << client_id_;
        }

        void done() {
            // Ugly, ugly, ugly
            LOG_TRACE << "If the program crash now, it was a bad idea to delete this ;)  #"
                      << client_id_ << " at address " << this;
            delete static_cast<T *>(this);
        }

        std::string me() const {
            return boost::typeindex::type_id_runtime(static_cast<const T&>(*this)).pretty_name()
                   + " #"
                   + std::to_string(client_id_);
        }

    protected:
        const size_t client_id_ = getNewClientId();
    };

    template <typename T, typename... Args>
    static auto createNew(GrpcServer& parent, Args... args) {

        try {
            return new T(parent, args...);
            // If we got here, the instance should be fine, so let it handle itself.
        } catch(const std::exception& ex) {
            LOG_ERROR << "Got exception while creating a new instance. "
                      << "This ends the jurney for this instance of me. "
                      << " Error: " << ex.what();
        }

        abort();
    }

    /*! RPC implementation
     *
     *  This class overrides our RPC methods from the code
     *  generatoed by rpcgen. This is where we receive the RPC events from gRPC.
     */
    class SignupImpl : public ::signup::pb::SignUp::CallbackService {
    public:
        SignupImpl(GrpcServer& owner)
            : owner_{owner} {}

        ::grpc::ServerUnaryReactor * GetInfo(::grpc::CallbackServerContext *ctx,
                                            const signup::pb::GetInfoRequest *req,
                                            signup::pb::GetInfoResponse *reply) override;

    private:
        // Boilerplate code to run async SQL queries or other async coroutines from an unary gRPC callback
        template <typename ReqT, typename ReplyT, typename FnT>
        ::grpc::ServerUnaryReactor*
        unaryHandler(::grpc::CallbackServerContext *ctx, const ReqT * req, ReplyT *reply, FnT fn, std::string_view name = {}) noexcept {
            assert(ctx);
            assert(reply);

            auto* reactor = ctx->DefaultReactor();

            boost::asio::co_spawn(owner_.server().ctx(), [this, ctx, req, reply, reactor, fn=std::move(fn), name]() -> boost::asio::awaitable<void> {
                try {
                    LOG_TRACE << "Request [" << name << "] " << req->GetDescriptor()->name() << ": " << owner_.toJsonForLog(*req);
                    co_await fn(reply);
                    LOG_TRACE << "Replying [" << name << "]: " << owner_.toJsonForLog(*reply);
                    reactor->Finish(::grpc::Status::OK);
                } catch (const std::exception& ex) {
                    LOG_WARN << "Request [" << name << "] Caught exception while handling grpc request coro: " << ex.what();
                    reactor->Finish(::grpc::Status::CANCELLED);
                }

                LOG_TRACE << "Request [" << name << "] Exiting unary handler.";

            }, boost::asio::detached);

            return reactor;
        }

        GrpcServer& owner_;
    };

    GrpcServer(Server& server);

    Server& server() {
        return server_;
    }

    void start();

    void stop();

    const GrpcConfig& config() const noexcept {
        return server_.config().grpc;
    }

private:
    // The Server instance where we get objects in the application, like config and database
    Server& server_;

    // Thread-safe method to get a unique client-id for a new RPC.
    static size_t getNewClientId() {
        static std::atomic_size_t id{0};
        return ++id;
    }

    // An instance of our service, compiled from code generated by protoc
    std::unique_ptr<SignupImpl> service_;

    // A gRPC server object
    std::unique_ptr<::grpc::Server> grpc_server_;

    mutable std::mutex mutex_;
    std::atomic_bool active_{false};
};

} // ns
