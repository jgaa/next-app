name: Verify & Smoke-run macOS app (from DMG, via gh)

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version string (e.g. 0.13.0). If empty, use latest successful build on main."
        required: false
  workflow_run:
    workflows: ["Build macOS App"]   # ← must match your build workflow *name*
    types: [completed]

permissions:
  actions: read
  contents: read

env:
  BUILD_WORKFLOW_FILE: build-macos-arm64.yaml   # ← your build workflow file path/name
  ARTIFACT_PREFIX: nextapp-macos-arm64-dmg-     # artifact names look like: nextapp-macos-arm64-dmg-0.13.0
  ARTIFACTS_DIR: artifacts

jobs:
  verify-and-run:
    runs-on: macos-14
    # only auto-run for successful builds on main
    if: ${{ github.event_name != 'workflow_run' || (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main') }}

    steps:
      - name: Checkout (empty)
        uses: actions/checkout@v4

      - name: Resolve RUN_ID and ARTIFACT pattern/name
        id: resolve
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          echo "event: ${{ github.event_name }}"
          # Decide RUN_ID
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            RUN_ID="${{ github.event.workflow_run.id }}"
          else
            # Manual run -> pick latest successful run of the build workflow on main
            RUN_ID=$(gh run list \
              --repo "${{ github.repository }}" \
              --workflow "${BUILD_WORKFLOW_FILE}" \
              --branch main \
              --status success \
              --limit 1 \
              --json databaseId \
              --jq '.[0].databaseId')
          fi

          if [[ -z "${RUN_ID:-}" || "${RUN_ID}" == "null" ]]; then
            echo "::error::No successful macOS/arm64 build run found on main."
            exit 1
          fi
          echo "RUN_ID=$RUN_ID" >> "$GITHUB_OUTPUT"

          # Artifact selection: exact name if version provided; otherwise pattern
          VERSION_INPUT="${{ inputs.version || '' }}"
          if [[ -n "${VERSION_INPUT}" ]]; then
            ARTIFACT_NAME="${ARTIFACT_PREFIX}${VERSION_INPUT}"
            echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"
          else
            ARTIFACT_PATTERN="${ARTIFACT_PREFIX}*"
            echo "ARTIFACT_PATTERN=$ARTIFACT_PATTERN" >> "$GITHUB_OUTPUT"
          fi

          echo "Resolved RUN_ID=${RUN_ID}"
          echo "Version input='${VERSION_INPUT:-<none>}'"

      - name: List artifacts for debugging
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          gh run view "${{ steps.resolve.outputs.RUN_ID }}" --repo "${{ github.repository }}" --log || true
          echo "----- Artifacts in run -----"
          gh api \
            repos/${{ github.repository }}/actions/runs/${{ steps.resolve.outputs.RUN_ID }}/artifacts \
            --jq '.artifacts[] | {name, expired, size_in_bytes}'

      - name: Download artifact (exact name if version provided)
        if: ${{ steps.resolve.outputs.ARTIFACT_NAME != '' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          mkdir -p "${ARTIFACTS_DIR}"
          gh run download "${{ steps.resolve.outputs.RUN_ID }}" \
            --repo "${{ github.repository }}" \
            --name "${{ steps.resolve.outputs.ARTIFACT_NAME }}" \
            --dir "${ARTIFACTS_DIR}"

      - name: Download artifact (pattern fallback when no version provided)
        if: ${{ steps.resolve.outputs.ARTIFACT_NAME == '' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          mkdir -p "${ARTIFACTS_DIR}"
          gh run download "${{ steps.resolve.outputs.RUN_ID }}" \
            --repo "${{ github.repository }}" \
            --pattern "${{ steps.resolve.outputs.ARTIFACT_PATTERN }}" \
            --dir "${ARTIFACTS_DIR}"

      - name: Locate DMG
        id: find_dmg
        run: |
          set -euo pipefail
          DMG=$(ls -1 "${ARTIFACTS_DIR}"/*.dmg | head -n1 || true)
          if [[ -z "${DMG}" ]]; then
            echo "::error::No .dmg found in ${ARTIFACTS_DIR}."
            echo "Check the artifact names printed above and your upload step."
            exit 66
          fi
          echo "dmg=$DMG" >> "$GITHUB_OUTPUT"
          echo "Found DMG: $DMG"

      - name: Mount DMG (read-only)
        id: mount
        run: |
          set -euo pipefail
          OUT=$(hdiutil attach -nobrowse -readonly "${{ steps.find_dmg.outputs.dmg }}")
          echo "$OUT"
          MOUNT_POINT=$(echo "$OUT" | awk '/Volumes/ {print $3; exit}')
          test -n "$MOUNT_POINT" || { echo "Failed to get mount point"; exit 67; }
          echo "mount_point=$MOUNT_POINT" >> "$GITHUB_OUTPUT"

      - name: Copy .app out of DMG
        run: |
          set -euo pipefail
          MP="${{ steps.mount.outputs.mount_point }}"
          APP_IN_DMG=$(find "$MP" -maxdepth 2 -name "NextApp.app" -print -quit)
          test -n "$APP_IN_DMG" || { echo "NextApp.app not found in DMG"; exit 68; }
          mkdir -p out
          ditto "$APP_IN_DMG" out/NextApp.app
          xattr -dr com.apple.quarantine out/NextApp.app || true
          echo "APP=out/NextApp.app" >> "$GITHUB_ENV"

      - name: Unmount DMG
        if: always()
        run: |
          MP="${{ steps.mount.outputs.mount_point }}"
          [[ -n "$MP" ]] && hdiutil detach "$MP" || true

      - name: Validate architecture & dylibs
        run: |
          set -euo pipefail
          BIN="$APP/Contents/MacOS/NextApp"
          file "$BIN"
          lipo -info "$BIN"
          lipo -verify_arch arm64 "$BIN" || { echo "Missing arm64 slice"; exit 65; }
          otool -arch arm64 -L "$BIN"
          FAIL=0
          while IFS= read -r f; do
            if file "$f" | grep -q 'Mach-O'; then
              if ! lipo -verify_arch arm64 "$f" 2>/dev/null; then
                echo "❌ Not arm64: $f"; FAIL=1
              fi
            fi
          done < <(find "$APP" -type f)
          exit $FAIL

      - name: Check RPATHs
        run: |
          otool -arch arm64 -l "$APP/Contents/MacOS/NextApp" | awk '/LC_RPATH/,/cmdsize/'

      - name: Verify code signature strictly
        run: |
          set -e
          codesign -dvv --verbose=4 "$APP"
          codesign --verify --deep --strict --verbose=2 "$APP" || exit 64
          spctl -a -vv --type execute "$APP" || true

      - name: Notarization ticket (if stapled)
        run: xcrun stapler validate -v "$APP" || true

      - name: Smoke-launch (Qt offscreen) and collect logs
        run: |
          set -euo pipefail
          BIN="$APP/Contents/MacOS/NextApp"
          export QT_QPA_PLATFORM=offscreen
          export QT_LOGGING_RULES="*.debug=true"
          "$BIN" -platform offscreen > run.log 2>&1 & echo $! > app.pid
          for i in {1..10}; do
            if ! kill -0 $(cat app.pid) 2>/dev/null; then
              echo "App exited (may be fine)."; break
            fi; sleep 1
          done
          if kill -0 $(cat app.pid) 2>/dev/null; then
            echo "Timeout, stopping app"; kill $(cat app.pid) || true
          fi
          tail -n +1 run.log || true

      - name: Upload verification artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nextapp-macos-verify
          path: |
            ${{ env.APP }}
            run.log
